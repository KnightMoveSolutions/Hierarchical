

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Recursion &mdash; KnightMoves.Pipelines 2.1.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="SortableTreePath" href="sortable-tree-path.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #0255a3" >
          

          
            <a href="index.html">
          

          
            
            <img src="_static/knight_move_solutions_hierarchical_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick-start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="properties.html">Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="sortable-tree-path.html">SortableTreePath</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Recursion</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">KnightMoves.Pipelines</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Recursion</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/recursion.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p><a class="reference external" href="https://docs.knightmovesolutions.com">Documentation Home</a></p>
<div class="section" id="recursion">
<h1>Recursion<a class="headerlink" href="#recursion" title="Permalink to this headline">¶</a></h1>
<p>You can process the nodes of your tree of objects recursively without having to code a recursive function.</p>
<p>First you would create the code that processes the nodes of the tree by implementing <code class="docutils literal notranslate"><span class="pre">ITreeNodeProcessor&lt;TId,</span> <span class="pre">T&gt;</span></code>,
which requires the implementation of one method called <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">ProcessNode(ITreeNode&lt;TId,</span> <span class="pre">T&gt;</span> <span class="pre">node)</span></code>.</p>
<p>For example:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTreeNodeProcessor</span> <span class="p">:</span> <span class="n">ITreeNodeProcessor</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Person</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">TestOutput</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">MyTreeNodeProcessor</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">TestOutput</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">ProcessNode</span><span class="p">(</span><span class="n">ITreeNode</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Person</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TestOutput</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Id</span> <span class="p">+</span> <span class="s">&quot; Processed&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then you just feed it to the top of the node you want to process. In the example below, we process every
node in the tree because we start at the root node.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">myProcessor</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyTreeNodeProcessor</span><span class="p">();</span>
<span class="n">familyTree</span><span class="p">.</span><span class="n">ProcessTree</span><span class="p">(</span><span class="n">myProcessor</span><span class="p">);</span>
</pre></div>
</div>
<p>However, if you want to process only a branch, then you can pass the tree node processor to the root of
that branch only. If you want to exclude the root node (or root of branch node) and process starting with
its children, then you can use the <code class="docutils literal notranslate"><span class="pre">ProcessChildren(ITreeNode&lt;TId,</span> <span class="pre">T&gt;</span> <span class="pre">node)</span></code> method instead.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">myProcessor</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyTreeNodeProcessor</span><span class="p">();</span>
<span class="n">familyTree</span><span class="p">.</span><span class="n">ProcessChildren</span><span class="p">(</span><span class="n">myProcessor</span><span class="p">);</span>
</pre></div>
</div>
<p>As you can see, you can just write your business logic and forget about having to recurse. Your tree node
processor could act on the node or not depending on the logic. If your entity is a View Model, you can set
property values to drive user interface changes such as setting <code class="docutils literal notranslate"><span class="pre">IsHighlighted</span> <span class="pre">=</span> <span class="pre">true</span></code> if the object
matches a search string.</p>
<p>You can make this shorter by using a lambda.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">testOutput</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>

<span class="n">familyTree</span><span class="p">.</span><span class="n">ProcessTree</span><span class="p">(</span><span class="n">node</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">testOutput</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Id</span> <span class="p">+</span> <span class="s">&quot; Processed&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The return value of the <code class="docutils literal notranslate"><span class="pre">ProcessTree</span></code> method is the logical AND result of all the resulting processing of
the nodes. To illustrate consider the following example:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">testOutput</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>

<span class="kt">bool</span> <span class="n">okay</span> <span class="p">=</span> <span class="n">familyTree</span><span class="p">.</span><span class="n">ProcessTree</span><span class="p">(</span><span class="n">node</span> <span class="p">=&gt;</span> <span class="p">{</span>

    <span class="kt">bool</span> <span class="n">result</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

    <span class="c1">// Test the node for something</span>
    <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">IsManager</span> <span class="p">==</span> <span class="k">false</span><span class="p">)</span>
        <span class="n">result</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="n">testOutput</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Id</span> <span class="p">+</span> <span class="s">&quot; Processed&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">});</span>

<span class="k">if</span><span class="p">(</span><span class="n">okay</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// All nodes processed returned true</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// At least one of the nodes that were processed failed</span>
    <span class="c1">// whatever condition you coded in the function</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can also process ancestor nodes up the tree as easy as you can process children. Just use one of the
similar <code class="docutils literal notranslate"><span class="pre">ProcessAncestors</span></code> methods.</p>
<p>The example below uses the sample hierarchy above where the me <code class="docutils literal notranslate"><span class="pre">Person</span></code> object is the third level down
(i.e. grandchild):</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">testOutput</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>

<span class="c1">// Starts with the `me` object and processes up to the</span>
<span class="c1">// root (grandpa object) because maxLevel == 1 by default</span>
<span class="kt">bool</span> <span class="n">okay</span> <span class="p">=</span> <span class="n">familyTree</span><span class="p">.</span><span class="n">ProcessAncestors</span><span class="p">(</span>
    <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">testOutput</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Id</span> <span class="p">+</span> <span class="s">&quot; Processed&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="n">me</span>
<span class="p">);</span>
</pre></div>
</div>
<p>You can cause it to stop recursing up the ancestor line early by setting the maxLevel value</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">testOutput</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>

<span class="c1">// Starts with the `me` object and processes up to the</span>
<span class="c1">// 2nd level (dad object) because maxLevel == 2</span>
<span class="kt">bool</span> <span class="n">okay</span> <span class="p">=</span> <span class="n">familyTree</span><span class="p">.</span><span class="n">ProcessAncestors</span><span class="p">(</span>
    <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">testOutput</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Id</span> <span class="p">+</span> <span class="s">&quot; Processed&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="n">me</span><span class="p">,</span>
    <span class="m">2</span>
<span class="p">);</span>
</pre></div>
</div>
<p>If the logic to stop it from going up the ancestor tree early is more complicated, then you can
provide a stopFunction with more robust logic to determine if it should stop climbing the tree.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">testOutput</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>

<span class="c1">// Starts with the `me` object and processes up to the</span>
<span class="c1">// level that satisfies the stopFunction</span>
<span class="kt">bool</span> <span class="n">okay</span> <span class="p">=</span> <span class="n">familyTree</span><span class="p">.</span><span class="n">ProcessAncestors</span><span class="p">(</span>
    <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">testOutput</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Id</span> <span class="p">+</span> <span class="s">&quot; Processed&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="n">me</span><span class="p">,</span>
    <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">Id</span> <span class="p">==</span> <span class="s">&quot;Dad&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">);</span>
</pre></div>
</div>
<p>The stopping logic first processes the current node and then evaluates whether it should stop or not.
If true, it will return without climbing to the next level. Keep in mind that it does that only after
executing your <code class="docutils literal notranslate"><span class="pre">ITreeNodeProcessor&lt;TId,</span> <span class="pre">T&gt;</span></code> or your <code class="docutils literal notranslate"><span class="pre">nodeProcessor</span></code> lambda function against the
current node first.</p>
<p>So you can see that with one quick function in a method call you can test an entire tree for something
whether you’re going down recursively to all children/branches or up the ancestor line of the tree.</p>
<p>There is no equivalent for a logical OR processing of the nodes, where it would return true if ANY
of the tests in the condition resulted in true. However, you can code this yourself as part of your
function. Just keep OR’ing some boolean that is outside of the function. This sets you up to do all
kinds of neat things with trees easily.</p>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="sortable-tree-path.html" class="btn btn-neutral float-left" title="SortableTreePath" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Ricardo Pena.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>